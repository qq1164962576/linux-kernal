一:linux内核的分页
 1:前言:内存线性\虚拟地址的长度决定了分页的级别是二级分页(页目录+页表)还是三级甚至四级分页,而分页的级别决定了一个内存地址
 字段的划分是3个字段还是是几个.
 ps:页目录也是一种特殊的页表.
 2:linux四级分页:
 linux采取四级分页模型来对32位以及64位系统进行分页.对任何一个进程linux内核都创建了4个数组表.
 (1)页全局目录===>(2)页上级目录===>(3)页中间目录===>(4)页表
  其中页全局目录存放页上级目录对象,每一个表项都是一个页上级目录对象.
  页上级目录存放页中级目录对象,每一个表项都是一个页中级目录对象.
  页中间目录存放页表对象,每一个表项都是一个页表对象.
  页表存放页面对象,每一个表项都是一个页面对象.
  其中页全局对象,页上级对象,页中间对象,页表对象都是一个数组
 (2)把一个内存地址分成,页全局目录offset+页上级offset+页中间offset+页表offset+物理页框offset
 (3)分页单元和linux内核转换时:
 1:通过cr3寄存器中页全局目录的基地址+页全局目录offset = 页全局目录的一项指向页上级目录对象
 2:通过第一步得到的页上级目录对象的基地址+页上级目录offset = 页上级目录的一项指向页中间目录对象
 3:通过第二步得到的页中间目录对象的基地址+页中间目录offset = 页中间目录的一项指向页表对象
 4:通过第三部得到的页表对象的基地址+页表offset = 页表对象的一项指向页面和页框映射对象,或者叫页面对象.
 5:通过第四部得到物理页框基地址+页框offset = 物理地址 分页结束
 3:linux的分页思想:
   linux的分页是一种使用32位和64位的通用分页模型(也可叫做分页算法),主要思想是:
   通过增加页表数组表来扩大分级分页模型,其中页目录等也是一种特殊的页表,并且指定页表上下级关系,上级页表
   包含并保存下级页表,并将内存线性\虚拟地址分成多个字段,每个字段都存放页表或页目录的offset.然后从第一个页目录
   开始转换.转换时使用页表基地址(页表基地址保存在上一个页表中)+线性地址中存放的页表offset,直到转换到真正保存
   页面和页框映射关系的页表.这种分页模型的本质就是将线性地址分成多个字段,每个字段都与一个页表数组关作为offset
   指向页表的一项.这样地址扩大,就扩大分级,分级就增加页表,页表增加就把线性地址多分一个字段.